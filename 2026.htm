<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seamless Reactive Editor</title>
    <style>
        :root {
            --bg: #1e1e1e; --header-bg: #2d2d2d; --gutter-bg: #252525; --sidebar-bg: #252525;
            --text: #dcdcdc; --border: #333; --accent: #444; --input-bg: #3c3c3c;
            --folder-color: #dcb67a; --selection-bg: rgba(0, 122, 255, 0.35);
            --selection-text: #ffffff; --lh: 1.5; --base-fs: 16px; --header-h: 55px;
            --gutter-w: 75px; --scrollbar-thumb: #444; --scrollbar-track: transparent;
            --toolbar-h: 40px;
        }
        body[data-theme="light"] {
            --bg: #ffffff; --header-bg: #f3f3f3; --gutter-bg: #f8f8f8; --sidebar-bg: #f8f8f8;
            --text: #333333; --border: #ddd; --accent: #eee; --input-bg: #ffffff;
            --folder-color: #90a4ae; --selection-bg: rgba(0, 120, 215, 0.25);
            --selection-text: inherit; --scrollbar-thumb: #ccc;
        }
        ::selection { background: var(--selection-bg); color: var(--selection-text); }
        * { box-sizing: border-box; }
        body, html { 
            margin: 0; padding: 0; height: 100%; overflow: hidden; 
            background: var(--bg); font-family: 'Segoe UI', sans-serif; 
            color: var(--text); transition: background 0.2s; font-size: var(--base-fs);
            user-select: none; -webkit-user-select: none;
        }
        .main-wrapper { display: flex; height: 100vh; flex-direction: column; }
        .main-header {
            height: var(--header-h); background: var(--header-bg); 
            border-bottom: 1px solid var(--border);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 10px; flex-shrink: 0; z-index: 10;
        }
        .app-container { display: flex; flex-grow: 1; overflow: hidden; width: 100%; }
        #sidebar {
            width: 0; background: var(--sidebar-bg); display: flex; 
            flex-direction: column; transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            flex-shrink: 0; position: relative; overflow: hidden; 
        }
        body.sidebar-open #sidebar { min-width: 330px; }
        .sidebar-content-wrapper { display: flex; flex-direction: column; flex-grow: 1; border-right: 1px solid var(--border); overflow: hidden; }
        #sidebarControls { padding: 10px; display: none; flex-direction: column; gap: 10px; border-bottom: 1px solid var(--border); }
        #filterActions { display: flex; align-items: center; gap: 4px; flex-wrap: wrap; }
        
        .editor-main-container { display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; min-width: 0; }
        .editor-content-area { display: flex; flex-grow: 1; overflow: hidden; }
        
        .editor-toolbar {
            height: var(--toolbar-h);
            background: var(--gutter-bg);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 10px;
            gap: 8px;
            flex-shrink: 0;
        }
        .toolbar-label { font-size: 13px; opacity: 0.6; margin-right: 10px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        body.full-explorer #sidebar { width: 100% !important; min-width: 100% !important; }
        body.full-explorer .sidebar-content-wrapper { border-right: none; }
        body.full-explorer .editor-main-container { display: none; }
        
        body.full-explorer #expandSidebarBtn { margin-left: auto; }
        #fileFilter { width: 100%; background: var(--input-bg); border: 1px solid var(--border); color: var(--text); padding: 8px; border-radius: 4px; font-size: var(--base-fs); outline: none; user-select: text; -webkit-user-select: text; }
        .gutter-column { width: var(--gutter-w); display: flex; flex-direction: column; border-right: 1px solid var(--border); background: var(--gutter-bg); flex-shrink: 0; }
        .editor-column { flex-grow: 1; display: flex; flex-direction: column; min-width: 0; position: relative; }
        
        .icon-btn { background: transparent; border: 1px solid transparent; color: var(--text); width: 40px; height: 40px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; opacity: 0.7; flex-shrink: 0; transition: color 0.2s; }
        .toolbar-btn { width: 32px; height: 32px; }
        .icon-btn:hover:not(:disabled) { background: var(--accent); opacity: 1; }
        .icon-btn:disabled { opacity: 0.2; cursor: default; }
        .icon-btn.active-toggle { background: var(--selection-bg); opacity: 1; border-color: rgba(0, 122, 255, 0.5); }
        .icon-btn svg { width: 22px; height: 22px; fill: none; stroke: currentColor; stroke-width: 2; }
        .toolbar-btn svg { width: 18px; height: 18px; }

        .sun-icon { display: block; } .moon-icon { display: none; }
        body[data-theme="light"] .sun-icon { display: none; }
        body[data-theme="light"] .moon-icon { display: block; }
        .locked-icon, .unlocked-icon { display: none; }
        .is-unlocked .unlocked-icon { display: block; }
        body:not(.is-unlocked) .locked-icon { display: block; }
        .is-unlocked #lockBtn { color: #f39c12; opacity: 1; }
        
        #fileList, .editor-viewport { flex-grow: 1; overflow-y: auto; overflow-x: hidden; }
        #fileList::-webkit-scrollbar, .editor-viewport::-webkit-scrollbar { width: 8px; }
        #fileList::-webkit-scrollbar-track, .editor-viewport::-webkit-scrollbar-track { background: var(--scrollbar-track); }
        #fileList::-webkit-scrollbar-thumb, .editor-viewport::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 10px; border: 2px solid var(--bg); }
        #fileList::-webkit-scrollbar-thumb { border-color: var(--sidebar-bg); }
        .entry-item { padding: 10px 15px; cursor: pointer; display: flex; align-items: center; gap: 12px; font-size: var(--base-fs); white-space: nowrap; }
        .entry-item:hover { background: var(--accent); }
        .entry-item.active { background: var(--accent); }
        .entry-item.selected { background: var(--selection-bg); }
        .preview-text { color: #4ade80; font-weight: bold; margin-left: 8px; font-size: 0.9em; }
        .line-numbers { flex-grow: 1; color: #6e7681; text-align: center; padding-top: 10px; font-family: 'Consolas', monospace; font-size: var(--base-fs); line-height: var(--lh); user-select: none; overflow: hidden; }
        .editor-viewport { position: relative; }
        #editor { width: 100%; min-height: 100%; padding: 10px; outline: none; font-family: 'Consolas', monospace; font-size: var(--base-fs); line-height: var(--lh); white-space: pre; word-break: break-all; tab-size: 4; user-select: text; -webkit-user-select: text; -webkit-user-modify: read-write-plaintext-only; }
        
        #playPauseBtn .pause-icon { display: none; }
        #playPauseBtn.is-playing .play-icon { display: none; }
        #playPauseBtn.is-playing .pause-icon { display: block; }
        #audioTimer { font-family: 'Consolas', monospace; font-size: 13px; opacity: 0.6; margin-right: 8px; display: none; cursor: pointer; pointer-events: auto; user-select: none; }
        #audioTimer:hover { opacity: 1; }
        #volumeSlider { width: 80px; height: 4px; cursor: pointer; accent-color: var(--text); display: none; margin-right: 10px; }
        .breadcrumb-container { font-size: 14px; display: flex; align-items: center; overflow: hidden; font-family: 'Segoe UI', sans-serif; color: var(--text); }
        .crumb { color: var(--text); cursor: pointer; padding: 2px 0px; white-space: nowrap; opacity: 0.8; }
        .crumb:hover { opacity: 1; }
        .crumb-sep { color: var(--text); margin: 0 4px; flex-shrink: 0; opacity: 0.4; }
        .crumb-file { cursor: default; font-weight: bold; opacity: 1; }
        footer { height: 42px; background: var(--header-bg); border-top: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; padding: 0 15px; font-size: 14px; color: var(--text); flex-shrink: 0; }
        #stat-container { display: none; align-items: center; gap: 25px; }
        #stat-totals, #stat-pos { color: var(--text); opacity: 0.8; }
        .menu-group { display: flex; align-items: center; gap: 4px; }
        .context-btn { display: none; }
        #selectionCountDisplay { font-weight: bold; color: var(--text); margin-right: 15px; flex-shrink: 0; }
        .zip-icon { color: #f1c40f !important; }
        .audio-icon { color: #a29bfe !important; }
        @keyframes flashSync { 0% { opacity: 1; } 100% { opacity: 0; } }
        .sync-active { animation: flashSync 2s ease-out; }
    </style>
</head>
<body data-theme="dark">

<div class="main-wrapper">
    <header class="main-header">
        <div class="menu-group">
            <button class="icon-btn" id="openBtn" title="Open Directory">
                <svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>
            </button>
            <button class="icon-btn context-btn" id="lockBtn" title="Toggle Edit Mode">
                <svg class="locked-icon" viewBox="0 0 24 24"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
                <svg class="unlocked-icon" viewBox="0 0 24 24"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 9.9-1"/></svg>
            </button>
        </div>

        <div class="menu-group">
            <span id="audioTimer" title="Click to toggle Remaining/Current View">00</span>
            <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.15" title="Volume">
            <button class="icon-btn" id="playPauseBtn" disabled title="Play/Pause Audio">
                <svg class="play-icon" viewBox="0 0 24 24"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                <svg class="pause-icon" viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
            </button>
            <button class="icon-btn" id="decFontBtn" title="Decrease Text Size">
                <svg viewBox="0 0 24 24"><line x1="5" y1="12" x2="19" y2="12"/></svg>
            </button>
            <button class="icon-btn" id="incFontBtn" title="Increase Text Size">
                <svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
            </button>
            <button class="icon-btn" id="themeBtn" title="Toggle Theme">
                <svg class="sun-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><path d="M12 1v2m0 18v2M4.2 4.2l1.4 1.4m12.8 12.8l1.4 1.4M1 12h2m18 0h2M4.2 19.8l1.4-1.4M18.4 5.6l1.4-1.4"/></svg>
                <svg class="moon-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
            </button>
        </div>
    </header>

    <div class="app-container">
        <div id="sidebar">
            <div class="sidebar-content-wrapper">
                <div id="sidebarControls">
                    <div id="filterActions">
                        <button class="icon-btn context-btn" id="upBtn" disabled title="Up to Parent"><svg viewBox="0 0 24 24"><path d="M15 18l-6-6 6-6"/></svg></button>
                        <button class="icon-btn context-btn" id="forwardBtn" disabled title="Go Forward/Back to Child"><svg viewBox="0 0 24 24"><path d="M9 6l6 6-6 6"/></svg></button>
                        <button class="icon-btn context-btn" id="newFileBtn" title="New File"><svg viewBox="0 0 24 24"><path d="M12 5v14M5 12h14"/></svg></button>
                        <button class="icon-btn context-btn" id="newDirBtn" title="New Folder"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2v11"/><path d="M12 11v6M9 14h6"/></svg></button>
                        <button class="icon-btn context-btn" id="multiSelectBtn" title="Multiple Select"><svg viewBox="0 0 24 24"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></button>
                        <button class="icon-btn context-btn" id="reverseSelectBtn" title="Reverse Selection"><svg viewBox="0 0 24 24"><path d="M7 2v20M17 2v20M7 2l-4 4M7 22l4-4M17 2l4 4M17 22l-4-4"/></svg></button>
                        <button class="icon-btn context-btn" id="deleteBtn" disabled title="Delete Selected"><svg viewBox="0 0 24 24"><path d="M3 6h18m-2 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></button>
                        
                        <button class="icon-btn context-btn" id="renameBtn" title="Rename (Active File / Bulk Regex)" disabled>
                            <svg viewBox="0 0 24 24"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                        </button>

                        <button class="icon-btn context-btn" id="zipBtn" title="Create or Update ZIP"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></button>
                        <button class="icon-btn context-btn" id="recursiveBtn" title="Recursive Filter"><svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg></button>
                        <button class="icon-btn context-btn" id="expandSidebarBtn" title="Toggle Full Width Explorer">
                            <svg class="expand-icon" viewBox="0 0 24 24"><path d="M13 17l5-5-5-5M6 17l5-5-5-5"/></svg>
                            <svg class="collapse-icon" viewBox="0 0 24 24"><path d="M11 17l-5-5 5-5M18 17l-5-5 5-5"/></svg>
                        </button>
                    </div>
                    <input type="text" id="fileFilter" placeholder="Filter / Regex Pattern" spellcheck="false">
                </div>
                <div id="fileList"></div>
            </div>
        </div>
        
        <div class="editor-main-container">
            <div class="editor-toolbar">
                <span class="toolbar-label" id="activeFileName">No file open</span>
                
                <button class="icon-btn toolbar-btn" id="undoBtn" disabled title="Undo">
                    <svg viewBox="0 0 24 24"><path d="M9 14L4 9l5-5"/><path d="M20 20v-7a4 4 0 0 0-4-4H4"/></svg>
                </button>
                <button class="icon-btn toolbar-btn" id="redoBtn" disabled title="Redo">
                    <svg viewBox="0 0 24 24"><path d="M15 14l5-5-5-5"/><path d="M4 20v-7a4 4 0 0 1 4-4h12"/></svg>
                </button>
                
                <div style="width: 1px; height: 20px; background: var(--border); margin: 0 5px;"></div>

                <button class="icon-btn toolbar-btn" id="saveBtn" title="Save Now" disabled>
                    <svg viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>
                </button>
                <button class="icon-btn toolbar-btn" id="renameBtn" title="Rename" disabled>
                    <svg viewBox="0 0 24 24"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                </button>
                <button class="icon-btn toolbar-btn" id="copyContentBtn" title="Copy File Content" disabled>
                    <svg viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
                </button>
                <button class="icon-btn toolbar-btn" id="pasteContentBtn" title="Paste from Clipboard" disabled>
                    <svg viewBox="0 0 24 24"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/></svg>
                </button>

                <button class="icon-btn toolbar-btn" id="closeFileBtn" title="Close Workspace" style="margin-left:auto">
                    <svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                </button>
            </div>

            <div class="editor-content-area">
                <div class="gutter-column"><div class="line-numbers" id="lineNumbers"></div></div>
                <div class="editor-column">
                    <div class="editor-viewport" id="viewport">
                        <div id="editor" contenteditable="false" spellcheck="false"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer>
        <div style="display:flex; align-items: center; overflow: hidden;">
            <div id="selectionCountDisplay"></div>
            <div class="breadcrumb-container" id="pathDisplay"></div>
            <div id="sync-status" style="color: #4ade80; font-weight: bold; opacity: 0; margin-left: 15px; flex-shrink: 0;">● Synced</div>
        </div>
        <div id="stat-container" style="flex-shrink: 0;">
            <span id="stat-pos" style="display:none; margin-right: 25px;">Line : 1 Offset : 0</span>
            <span id="stat-totals"></span>
        </div>
    </footer>
</div>

<script>
    window.addEventListener('contextmenu', (e) => e.preventDefault());

    const editor = document.getElementById('editor');
    const lineNumbers = document.getElementById('lineNumbers');
    const viewport = document.getElementById('viewport');
    const sidebar = document.getElementById('sidebar');
    const fileList = document.getElementById('fileList');
    const openBtn = document.getElementById('openBtn');
    const lockBtn = document.getElementById('lockBtn');
    const expandBtn = document.getElementById('expandSidebarBtn');
    const multiSelectBtn = document.getElementById('multiSelectBtn');
    const reverseSelectBtn = document.getElementById('reverseSelectBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const zipBtn = document.getElementById('zipBtn');
    const newFileBtn = document.getElementById('newFileBtn');
    const newDirBtn = document.getElementById('newDirBtn');
    const recursiveBtn = document.getElementById('recursiveBtn');
    const statPos = document.getElementById('stat-pos');
    const statTotals = document.getElementById('stat-totals');
    const statContainer = document.getElementById('stat-container');
    const pathDisplay = document.getElementById('pathDisplay');
    const fileFilter = document.getElementById('fileFilter');
    const sidebarControls = document.getElementById('sidebarControls');
    const upBtn = document.getElementById('upBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const selectionCountDisplay = document.getElementById('selectionCountDisplay');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const audioTimer = document.getElementById('audioTimer');
    const volumeSlider = document.getElementById('volumeSlider');
    const themeBtn = document.getElementById('themeBtn');
    const incFontBtn = document.getElementById('incFontBtn');
    const decFontBtn = document.getElementById('decFontBtn');
    const syncStatus = document.getElementById('sync-status');
    
    const activeFileName = document.getElementById('activeFileName');
    const saveBtn = document.getElementById('saveBtn');
    const renameBtn = document.getElementById('renameBtn');
    const copyContentBtn = document.getElementById('copyContentBtn');
    const pasteContentBtn = document.getElementById('pasteContentBtn'); 
    const closeFileBtn = document.getElementById('closeFileBtn');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');

    let currentHandle = null; 
    let rootHandle = null;
    let navHistory = []; 
    let historyIndex = -1;
    let baseFontSize = 16;
    let currentEntries = [];
    let isMultiSelect = false;
    let isRecursiveFilter = false;
    let selectedHandles = new Set();
    let currentFileHandle = null;
    
    let isInsideZip = false;
    let zipRootEntry = null; 
    let zipData = new Map(); 

    let audioContext = null;
    let streamNode = null;
    let hiddenAudio = null; 
    let timerInterval = null;
    let showRemainingTime = true; 
    const audioExtensions = ['.mp3', '.wav', '.ogg', '.m4a', '.flac'];

    const crcTable = (() => {
        const t = [];
        for (let i = 0; i < 256; i++) {
            let c = i;
            for (let j = 0; j < 8; j++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
            t[i] = c;
        }
        return t;
    })();
    function crc32(data) {
        let crc = 0 ^ -1;
        for (let i = 0; i < data.length; i++) crc = (crc >>> 8) ^ crcTable[(crc ^ data[i]) & 0xFF];
        return (crc ^ -1) >>> 0;
    }

    class ZipProxyHandle {
        constructor(name, path, kind) {
            this.name = name;
            this.kind = kind; 
            this.path = path; 
        }
        async *values() {
            const cleanPath = this.path;
            const seen = new Set();
            for (const [key, val] of zipData) {
                if (key === cleanPath) continue; 
                if (key.startsWith(cleanPath)) {
                    const rel = key.substring(cleanPath.length);
                    const slashIndex = rel.indexOf('/');
                    if (slashIndex === -1 || slashIndex === rel.length - 1) {
                        if (!seen.has(key)) {
                            seen.add(key);
                            yield new ZipProxyHandle(rel.replace('/',''), key, val.kind);
                        }
                    } else {
                        const subDirName = rel.substring(0, slashIndex);
                        const subDirPath = cleanPath + subDirName + '/';
                        if (!seen.has(subDirPath)) {
                            seen.add(subDirPath);
                            yield new ZipProxyHandle(subDirName, subDirPath, 'directory');
                        }
                    }
                }
            }
        }
        async getFileHandle(name, opts) {
            const targetPath = this.path + name;
            if (opts?.create) {
                if (!zipData.has(targetPath)) {
                    zipData.set(targetPath, { kind: 'file', content: new Uint8Array(0), date: new Date() });
                    await flushZip();
                }
            }
            if (zipData.has(targetPath)) return new ZipProxyHandle(name, targetPath, 'file');
            throw new Error("File not found");
        }
        async getDirectoryHandle(name, opts) {
            const targetPath = this.path + name + '/';
            if (opts?.create) {
                if (!zipData.has(targetPath)) {
                    zipData.set(targetPath, { kind: 'directory', content: null, date: new Date() });
                    await flushZip();
                }
            }
            return new ZipProxyHandle(name, targetPath, 'directory');
        }
        async removeEntry(name, opts) {
            const filePath = this.path + name;
            const dirPath = this.path + name + '/';
            const toDelete = [];
            for (const key of zipData.keys()) {
                if (key === filePath || key === dirPath || key.startsWith(dirPath)) {
                    toDelete.push(key);
                }
            }
            if (toDelete.length > 0) {
                toDelete.forEach(k => zipData.delete(k));
                await flushZip();
            } else {
                throw new Error("Entry not found in ZIP");
            }
        }
        async move(newName) {
            const entry = zipData.get(this.path);
            zipData.delete(this.path);
            const newPath = this.path.substring(0, this.path.lastIndexOf(this.name)) + newName;
            zipData.set(newPath, entry);
            this.path = newPath;
            this.name = newName;
            await flushZip();
        }
        async getFile() {
             const entry = zipData.get(this.path);
             return new File([entry.content], this.name);
        }
        async createWritable() {
            return new WritableStream({
                write: async (chunk) => {
                    let data;
                    if (typeof chunk === 'string') data = new TextEncoder().encode(chunk);
                    else if (chunk instanceof Blob) data = new Uint8Array(await chunk.arrayBuffer());
                    else data = chunk;
                    zipData.set(this.path, { kind: 'file', content: data, date: new Date() });
                    await flushZip();
                }
            });
        }
        async resolve() { return null; }
    }

    async function parseZip(file) {
        const buffer = await file.arrayBuffer();
        const view = new DataView(buffer);
        zipData.clear();
        let eocdPos = -1;
        for (let i = buffer.byteLength - 22; i >= Math.max(0, buffer.byteLength - 1024); i--) {
            if (view.getUint32(i, true) === 0x06054b50) { eocdPos = i; break; }
        }
        if (eocdPos === -1) return; 
        const cdCount = view.getUint16(eocdPos + 10, true);
        const cdOffset = view.getUint32(eocdPos + 16, true);
        let ptr = cdOffset;
        const dec = new TextDecoder();
        for (let i = 0; i < cdCount; i++) {
            if (view.getUint32(ptr, true) !== 0x02014b50) break;
            const nameLen = view.getUint16(ptr + 28, true);
            const extraLen = view.getUint16(ptr + 30, true);
            const commLen = view.getUint16(ptr + 32, true);
            const lhOffset = view.getUint32(ptr + 42, true);
            const name = dec.decode(new Uint8Array(buffer, ptr + 46, nameLen));
            const lfhNameLen = view.getUint16(lhOffset + 26, true);
            const lfhExtraLen = view.getUint16(lhOffset + 28, true);
            const cSize = view.getUint32(lhOffset + 18, true);
            const content = new Uint8Array(buffer, lhOffset + 30 + lfhNameLen + lfhExtraLen, cSize);
            zipData.set(name, { kind: name.endsWith('/') ? 'directory' : 'file', content: content, date: new Date() });
            ptr += 46 + nameLen + extraLen + commLen;
        }
    }

    async function flushZip() {
        if (!zipRootEntry) return;
        const chunks = [];
        const cd = [];
        let offset = 0;
        const enc = new TextEncoder();
        const now = new Date();
        const time = ((now.getHours() << 11) | (now.getMinutes() << 5) | (now.getSeconds() >> 1));
        const date = (((now.getFullYear() - 1980) << 9) | ((now.getMonth() + 1) << 5) | now.getDate());
        for (const [path, entry] of zipData) {
            const nameBuf = enc.encode(path);
            const isDir = entry.kind === 'directory';
            const data = isDir ? new Uint8Array(0) : entry.content;
            const crc = isDir ? 0 : crc32(data);
            const lfh = new Uint8Array(30 + nameBuf.length);
            const dv = new DataView(lfh.buffer);
            dv.setUint32(0, 0x04034b50, true); dv.setUint16(4, 20, true); dv.setUint16(6, 0, true); dv.setUint16(8, 0, true);
            dv.setUint16(10, time, true); dv.setUint16(12, date, true); dv.setUint32(14, crc, true);
            dv.setUint32(18, data.length, true); dv.setUint32(22, data.length, true);
            dv.setUint16(26, nameBuf.length, true); dv.setUint16(28, 0, true);
            lfh.set(nameBuf, 30);
            chunks.push(lfh); chunks.push(data);
            cd.push({ nameBuf, crc, size: data.length, offset, time, date });
            offset += lfh.length + data.length;
        }
        const cdStart = offset;
        let cdLen = 0;
        for (const e of cd) {
            const cdh = new Uint8Array(46 + e.nameBuf.length);
            const dv = new DataView(cdh.buffer);
            dv.setUint32(0, 0x02014b50, true); dv.setUint16(4, 20, true); dv.setUint16(6, 20, true); dv.setUint16(8, 0, true);
            dv.setUint16(10, 0, true); dv.setUint16(12, e.time, true); dv.setUint16(14, e.date, true);
            dv.setUint32(16, e.crc, true); dv.setUint32(20, e.size, true); dv.setUint32(24, e.size, true);
            dv.setUint16(28, e.nameBuf.length, true); dv.setUint32(42, e.offset, true);
            cdh.set(e.nameBuf, 46); chunks.push(cdh); cdLen += cdh.length;
        }
        const eocd = new Uint8Array(22);
        const dvE = new DataView(eocd.buffer);
        dvE.setUint32(0, 0x06054b50, true); dvE.setUint16(8, cd.length, true); dvE.setUint16(10, cd.length, true);
        dvE.setUint32(12, cdLen, true); dvE.setUint32(16, cdStart, true);
        chunks.push(eocd);
        const blob = new Blob(chunks, {type: 'application/zip'});
        const w = await zipRootEntry.createWritable();
        await w.write(blob); await w.close();
        syncStatus.classList.remove('sync-active'); void syncStatus.offsetWidth; syncStatus.classList.add('sync-active');
    }

    function getCursorPosition() {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(editor);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            return { lineNum: preCaretRange.toString().split(/\r\n|\r|\n/).length, offset: preCaretRange.toString().length };
        }
        return { lineNum: 1, offset: 0 };
    }

    function updateEditorUI() {
        const text = editor.innerText;
        let lines = text.split(/\r\n|\r|\n/);
        if (text.endsWith('\n') || text === '') lines = text === '' ? [""] : [...lines, ""];
        lineNumbers.innerHTML = lines.map((_, i) => `<div>${i + 1}</div>`).join('');
        const pos = getCursorPosition();
        statPos.style.display = 'inline';
        statPos.textContent = `Line : ${pos.lineNum} Offset : ${pos.offset}`;
        statTotals.textContent = `${text.length} chars - ${lines.length} lines`;
        if (currentFileHandle) {
            clearTimeout(window.saveTimeout);
            window.saveTimeout = setTimeout(async () => {
                const w = await currentFileHandle.createWritable();
                await w.write(editor.innerText); await w.close();
                if(!isInsideZip) { syncStatus.classList.remove('sync-active'); void syncStatus.offsetWidth; syncStatus.classList.add('sync-active'); }
            }, 800);
        }
    }

    editor.oninput = updateEditorUI; editor.onclick = updateEditorUI; editor.onkeyup = updateEditorUI;

    openBtn.onclick = async () => {
        try {
            rootHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
            zipRootEntry = null; isInsideZip = false;
            document.body.classList.add('sidebar-open');
            sidebar.style.width = '330px'; 
            document.querySelectorAll('.context-btn').forEach(btn => btn.style.display = 'flex');
            sidebarControls.style.display = 'flex';
            await applyNavigationState(rootHandle, true);
        } catch (e) { console.error(e); }
    };

    async function applyNavigationState(state, pushToHistory = true) {
        currentHandle = state;
        selectedHandles.clear(); updateDeleteBtn(); updateSelectionUI();
        currentEntries = [];
        zipBtn.disabled = isInsideZip;
        zipBtn.style.opacity = isInsideZip ? "0.3" : "1";
        try { for await (const entry of state.values()) currentEntries.push(entry); } catch (e) {}
        renderFilteredList(); await updateBreadcrumbs(state);
        if (pushToHistory) {
            navHistory = navHistory.slice(0, historyIndex + 1);
            navHistory.push({ handle: state, isZip: isInsideZip, zipRoot: zipRootEntry });
            historyIndex++;
        }
        upBtn.disabled = (historyIndex <= 0) && !isInsideZip && state === rootHandle;
        forwardBtn.disabled = historyIndex >= navHistory.length - 1;
    }

    async function enterZip(fileHandle) {
        try {
            await parseZip(await fileHandle.getFile());
            zipRootEntry = fileHandle; isInsideZip = true;
            const virtualRoot = new ZipProxyHandle(fileHandle.name, "", 'directory');
            await applyNavigationState(virtualRoot, true);
        } catch (e) { alert("Unable to open ZIP: " + e.message); }
    }

    async function updateBreadcrumbs(handle) {
        pathDisplay.innerHTML = ''; if (!rootHandle) return;
        const rootCrumb = document.createElement('span');
        rootCrumb.className = 'crumb'; rootCrumb.textContent = rootHandle.name;
        rootCrumb.onclick = () => { isInsideZip = false; zipRootEntry = null; applyNavigationState(rootHandle, true); };
        pathDisplay.appendChild(rootCrumb);
        if (isInsideZip) {
             pathDisplay.appendChild(Object.assign(document.createElement('span'), {className:'crumb-sep', textContent:'/'}));
             const zipCrumb = document.createElement('span');
             zipCrumb.className = 'crumb'; zipCrumb.textContent = zipRootEntry.name;
             zipCrumb.onclick = () => { applyNavigationState(new ZipProxyHandle(zipRootEntry.name, "", "directory"), true); };
             pathDisplay.appendChild(zipCrumb);
             if (handle.path !== "") {
                 const parts = handle.path.split('/').filter(x => x);
                 let accum = "";
                 parts.forEach(p => {
                     accum += p + "/";
                     pathDisplay.appendChild(Object.assign(document.createElement('span'), {className:'crumb-sep', textContent:'/'}));
                     const crumb = document.createElement('span');
                     crumb.className = 'crumb'; crumb.textContent = p;
                     const target = accum; 
                     crumb.onclick = () => applyNavigationState(new ZipProxyHandle(p, target, 'directory'), true);
                     pathDisplay.appendChild(crumb);
                 });
             }
        } else if (handle !== rootHandle) {
            const path = await rootHandle.resolve(handle);
            if (path) {
                path.forEach((folder, index) => {
                    pathDisplay.appendChild(Object.assign(document.createElement('span'), {className:'crumb-sep', textContent:'/'}));
                    const crumb = document.createElement('span');
                    crumb.className = 'crumb'; crumb.textContent = folder;
                    crumb.onclick = async () => {
                        let cur = rootHandle;
                        for(const p of path.slice(0, index+1)) cur = await cur.getDirectoryHandle(p);
                        applyNavigationState(cur, true);
                    };
                    pathDisplay.appendChild(crumb);
                });
            }
        }
    }

    async function renderFilteredList() {
        fileList.innerHTML = '';
        const filter = fileFilter.value;
        let regex = null;
        if (isMultiSelect && filter) {
            try { regex = new RegExp(filter); } catch(e) {}
        }

        if (!isRecursiveFilter || !filter) {
            document.body.classList.remove('searching');
            let displayEntries = currentEntries.filter(e => {
                if (!filter) return true;
                if (regex) return regex.test(e.name);
                return e.name.toLowerCase().includes(filter.toLowerCase());
            });
            displayEntries.sort((a,b) => (a.kind === b.kind ? a.name.localeCompare(b.name) : (a.kind === 'directory' ? -1 : 1)));
            displayEntries.forEach(e => {
                const h = e.handle || e;
                const matches = regex && selectedHandles.has(h) && regex.test(e.name);
                createEntryItem(e, null, matches);
            });
            return;
        }

        document.body.classList.add('searching');
        await performRecursiveSearch(currentHandle, filter, regex);
        document.body.classList.remove('searching');
    }

    async function performRecursiveSearch(startHandle, query, regex) {
        async function walk(handle, path = "") {
            if (isInsideZip || handle instanceof ZipProxyHandle) {
                for (const [key, entry] of zipData) {
                    const matches = regex ? regex.test(key) : key.toLowerCase().includes(query.toLowerCase());
                    if (matches) {
                        createEntryItem({
                            name: key,
                            kind: entry.kind,
                            handle: new ZipProxyHandle(key.split('/').pop() || key, key, entry.kind)
                        });
                    }
                }
                return;
            }

            for await (const entry of handle.values()) {
                const fullPath = path + entry.name;
                const matches = regex ? regex.test(entry.name) : entry.name.toLowerCase().includes(query.toLowerCase());
                if (matches) createEntryItem(entry, fullPath);
                if (entry.kind === 'directory') await walk(entry, fullPath + "/");
            }
        }
        await walk(startHandle);
    }

    function createEntryItem(e, displayPath, isRegexMatch) {
        const item = document.createElement('div');
        const h = e.handle || e;
        item.className = 'entry-item';
        if (selectedHandles.has(h)) item.classList.add('selected');
        
        const isZip = e.name.toLowerCase().endsWith('.zip');
        const isAudio = audioExtensions.includes('.' + e.name.split('.').pop().toLowerCase());
        const iconSvg = e.kind === 'directory' ? 
            `<svg style="color:var(--folder-color)" width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M10 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8z"/></svg>` : 
            `<svg class="${isZip?'zip-icon':(isAudio?'audio-icon':'')}" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/><path d="M13 2v7h7"/></svg>`;
        
        item.innerHTML = iconSvg;
        const span = document.createElement('span');
        span.textContent = displayPath || e.name; 
        item.appendChild(span);

        if (isRegexMatch) {
            const preview = document.createElement('span');
            preview.className = 'preview-text';
            preview.textContent = ' ➔ (Match)';
            item.appendChild(preview);
        }

        item.onclick = async () => {
            if (isMultiSelect) { 
                if (selectedHandles.has(h)) selectedHandles.delete(h); else selectedHandles.add(h);
                updateDeleteBtn(); updateSelectionUI(); renderFilteredList();
            } else if (e.kind === 'directory') {
                applyNavigationState(h, true);
            } else if (isZip && !isInsideZip) {
                enterZip(h);
            } else if (isAudio) {
                initStreamingAudio(await h.getFile(), e.name);
            } else {
                loadFile(h, item); document.body.classList.remove('full-explorer');
            }
        };
        fileList.appendChild(item);
    }

    function formatTime(seconds) {
        if (isNaN(seconds) || seconds < 0) return "00";
        const absS = Math.floor(seconds);
        const h = Math.floor(absS / 3600), m = Math.floor((absS % 3600) / 60), s = absS % 60;
        return h > 0 ? `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}` : `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    function updateTimerDisplay() {
        if (!hiddenAudio) return;
        audioTimer.textContent = showRemainingTime ? formatTime(hiddenAudio.duration - hiddenAudio.currentTime) : `${formatTime(hiddenAudio.currentTime)} / ${formatTime(hiddenAudio.duration)}`;
    }

    audioTimer.onclick = () => { showRemainingTime = !showRemainingTime; updateTimerDisplay(); };
    volumeSlider.oninput = () => { if (hiddenAudio) hiddenAudio.volume = volumeSlider.value; };

    async function initStreamingAudio(file, name) {
        if (hiddenAudio) { hiddenAudio.pause(); URL.revokeObjectURL(hiddenAudio.src); }
        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (!hiddenAudio) {
            hiddenAudio = new Audio(); hiddenAudio.crossOrigin = "anonymous";
            streamNode = audioContext.createMediaElementSource(hiddenAudio); streamNode.connect(audioContext.destination);
            hiddenAudio.onplay = () => { playPauseBtn.classList.add('is-playing'); timerInterval = setInterval(updateTimerDisplay, 500); };
            hiddenAudio.onpause = () => { playPauseBtn.classList.remove('is-playing'); clearInterval(timerInterval); };
            hiddenAudio.onended = () => { playPauseBtn.classList.remove('is-playing'); clearInterval(timerInterval); updateTimerDisplay(); volumeSlider.style.display = 'none'; };
        }
        hiddenAudio.src = URL.createObjectURL(file); hiddenAudio.volume = volumeSlider.value;
        playPauseBtn.disabled = false; audioTimer.style.display = 'inline'; volumeSlider.style.display = 'inline-block';
        if (audioContext.state === 'suspended') await audioContext.resume();
        hiddenAudio.play();
    }

    playPauseBtn.onclick = () => { if (!hiddenAudio) return; hiddenAudio.paused ? hiddenAudio.play() : hiddenAudio.pause(); };

    async function loadFile(h, el) {
        currentFileHandle = h; 
        const file = await h.getFile(); editor.innerText = await file.text();
        statContainer.style.display = 'flex'; updateEditorUI();
        document.querySelectorAll('.entry-item').forEach(i => i.classList.remove('active'));
        el?.classList.add('active');
        
        activeFileName.textContent = h.name;
        saveBtn.disabled = false;
        renameBtn.disabled = isInsideZip;
        copyContentBtn.disabled = false;
        pasteContentBtn.disabled = false;
        undoBtn.disabled = false;
        redoBtn.disabled = false;
        updateDeleteBtn(); // Refresh rename logic state
    }

    saveBtn.onclick = async () => {
        if (!currentFileHandle) return;
        const w = await currentFileHandle.createWritable();
        await w.write(editor.innerText); await w.close();
        if(!isInsideZip) { syncStatus.classList.remove('sync-active'); void syncStatus.offsetWidth; syncStatus.classList.add('sync-active'); }
    };

    renameBtn.onclick = async () => {
        if (isInsideZip) return;
        if (isMultiSelect && selectedHandles.size > 0) {
            const pattern = fileFilter.value;
            if (!pattern) {
                alert("Please enter a Regex pattern in the Filter box first.");
                return;
            }
            let regex;
            try { regex = new RegExp(pattern); } catch (e) { alert("Invalid Regex pattern."); return; }
            const replacement = prompt(`Bulk Rename ${selectedHandles.size} selected items.\nPattern: /${pattern}/\n\nEnter replacement text:`);
            if (replacement === null) return;
            for (const h of selectedHandles) {
                if (regex.test(h.name)) {
                    const newName = h.name.replace(regex, replacement);
                    try {
                        if (h.move) {
                            await h.move(newName);
                            if (h === currentFileHandle) activeFileName.textContent = newName;
                        }
                    } catch (e) { console.error(`Failed to rename ${h.name}: ${e.message}`); }
                }
            }
            selectedHandles.clear();
            updateSelectionUI();
            await applyNavigationState(currentHandle, false);
        } else if (currentFileHandle) {
            const nameParts = currentFileHandle.name.split('.');
            const ext = nameParts.length > 1 ? '.' + nameParts.pop() : '';
            const baseName = nameParts.join('.');
            const newBaseName = prompt(`Rename active file (extension ${ext} preserved):`, baseName);
            if (newBaseName && newBaseName !== baseName) {
                try {
                    const newFullName = newBaseName + ext;
                    if (currentFileHandle.move) {
                        await currentFileHandle.move(newFullName);
                        activeFileName.textContent = newFullName;
                        await applyNavigationState(currentHandle, false);
                    }
                } catch (e) { alert("Rename failed: " + e.message); }
            }
        }
    };

    copyContentBtn.onclick = async () => {
        if (!currentFileHandle) return;
        const content = editor.innerText;
        try {
            await navigator.clipboard.writeText(content);
            const originalTitle = copyContentBtn.title;
            const originalColor = copyContentBtn.style.color;
            copyContentBtn.style.color = "#4ade80"; 
            copyContentBtn.title = "Copied to clipboard!";
            setTimeout(() => {
                copyContentBtn.style.color = originalColor;
                copyContentBtn.title = originalTitle;
            }, 1500);
        } catch (err) { alert("Clipboard access denied."); }
    };

    pasteContentBtn.onclick = async () => {
        if (!currentFileHandle) return;
        try {
            const text = await navigator.clipboard.readText();
            editor.innerText = text; 
            updateEditorUI();
            const originalColor = pasteContentBtn.style.color;
            pasteContentBtn.style.color = "#4ade80"; 
            setTimeout(() => { pasteContentBtn.style.color = originalColor; }, 1500);
        } catch (err) { alert("Clipboard access denied."); }
    };

    closeFileBtn.onclick = () => {
        currentFileHandle = null;
        editor.innerText = '';
        activeFileName.textContent = 'No file open';
        saveBtn.disabled = true;
        renameBtn.disabled = true;
        copyContentBtn.disabled = true;
        pasteContentBtn.disabled = true;
        undoBtn.disabled = true;
        redoBtn.disabled = true;
        statContainer.style.display = 'none';
        lineNumbers.innerHTML = '';
        updateDeleteBtn();
    };

    function updateDeleteBtn() { 
        deleteBtn.disabled = selectedHandles.size === 0; 
        renameBtn.disabled = isInsideZip || (!currentFileHandle && selectedHandles.size === 0);
    }
    function updateSelectionUI() { selectionCountDisplay.textContent = selectedHandles.size > 0 ? `${selectedHandles.size} selected` : ''; }

    newFileBtn.onclick = async () => { if (!currentHandle) return; const name = prompt("New file name:"); if (name) { await currentHandle.getFileHandle(name, {create:true}); applyNavigationState(currentHandle, false); } };
    newDirBtn.onclick = async () => { if (!currentHandle) return; const name = prompt("New folder name:"); if (name) { await currentHandle.getDirectoryHandle(name, {create:true}); applyNavigationState(currentHandle, false); } };
    
    deleteBtn.onclick = async () => { 
        if (selectedHandles.size === 0) return; 
        if (confirm(`Delete ${selectedHandles.size} items?`)) { 
            for (const h of selectedHandles) { await currentHandle.removeEntry(h.name, {recursive:true}); }
            selectedHandles.clear(); 
            await applyNavigationState(currentHandle, false); 
        } 
    };

    zipBtn.onclick = async () => {
        if (!currentHandle || isInsideZip) return;
        const now = new Date();
        const defaultName = `${currentHandle.name}.zip`;
        const userRename = prompt("Create ZIP of current folder:", defaultName);
        if (userRename === null) return;
        const zipFileName = (userRename.trim() || defaultName).endsWith('.zip') ? userRename.trim() : userRename.trim() + ".zip";
        try {
            const enc = new TextEncoder();
            const chunks = []; const cd = []; let offset = 0;
            async function addFile(name, data) {
                 const nameBuf = enc.encode(name); const crc = crc32(data);
                 const time = ((now.getHours() << 11) | (now.getMinutes() << 5) | (now.getSeconds() >> 1));
                 const date = (((now.getFullYear() - 1980) << 9) | ((now.getMonth() + 1) << 5) | now.getDate());
                 const lfh = new Uint8Array(30 + nameBuf.length); const dv = new DataView(lfh.buffer);
                 dv.setUint32(0, 0x04034b50, true); dv.setUint16(4, 20, true); dv.setUint16(6, 0, true); dv.setUint16(8, 0, true);
                 dv.setUint16(10, time, true); dv.setUint16(12, date, true); dv.setUint32(14, crc, true);
                 dv.setUint32(18, data.length, true); dv.setUint32(22, data.length, true);
                 dv.setUint16(26, nameBuf.length, true); dv.setUint16(28, 0, true);
                 lfh.set(nameBuf, 30); chunks.push(lfh); chunks.push(data);
                 cd.push({nameBuf, crc, size: data.length, offset, time, date});
                 offset += lfh.length + data.length;
            }
            async function walk(dir, path="") {
                for await (const entry of dir.values()) {
                    if (entry.name === zipFileName) continue;
                    if (entry.kind === 'file') {
                        const f = await entry.getFile();
                        const b = new Uint8Array(await f.arrayBuffer());
                        await addFile(path + entry.name, b);
                    } else if (entry.kind === 'directory') {
                        await addFile(path + entry.name + '/', new Uint8Array(0));
                        await walk(dir, path + entry.name + '/');
                    }
                }
            }
            await walk(currentHandle);
            const cdStart = offset; let cdLen = 0;
            for (const e of cd) {
                const cdh = new Uint8Array(46 + e.nameBuf.length); const dv = new DataView(cdh.buffer);
                dv.setUint32(0, 0x02014b50, true); dv.setUint16(4, 20, true); dv.setUint16(6, 20, true); dv.setUint16(8, 0, true);
                dv.setUint16(10, 0, true); dv.setUint16(12, e.time, true); dv.setUint16(14, e.date, true);
                dv.setUint32(16, e.crc, true); dv.setUint32(20, e.size, true); dv.setUint32(24, e.size, true);
                dv.setUint16(28, e.nameBuf.length, true); dv.setUint32(42, e.offset, true);
                cdh.set(e.nameBuf, 46); chunks.push(cdh); cdLen += cdh.length;
            }
            const eocd = new Uint8Array(22); const dvE = new DataView(eocd.buffer);
            dvE.setUint32(0, 0x06054b50, true); dvE.setUint16(8, cd.length, true); dvE.setUint16(10, cd.length, true);
            dvE.setUint32(12, cdLen, true); dvE.setUint32(16, cdStart, true); chunks.push(eocd);
            const h = await currentHandle.getFileHandle(zipFileName, {create:true});
            const w = await h.createWritable(); await w.write(new Blob(chunks, {type: 'application/zip'})); await w.close();
            applyNavigationState(currentHandle, false);
        } catch (e) { alert(e.message); }
    };

    recursiveBtn.onclick = () => { isRecursiveFilter = !isRecursiveFilter; recursiveBtn.classList.toggle('active-toggle', isRecursiveFilter); renderFilteredList(); };
    fileFilter.oninput = renderFilteredList;
    multiSelectBtn.onclick = () => { isMultiSelect = !isMultiSelect; multiSelectBtn.classList.toggle('active-toggle', isMultiSelect); if(!isMultiSelect) { selectedHandles.clear(); updateSelectionUI(); updateDeleteBtn(); renderFilteredList(); } };
    
    // NEW FEATURE: REVERSE SELECTION LOGIC
    reverseSelectBtn.onclick = () => {
        if (!isMultiSelect) {
            isMultiSelect = true;
            multiSelectBtn.classList.add('active-toggle');
        }
        currentEntries.forEach(entry => {
            const h = entry.handle || entry;
            if (selectedHandles.has(h)) {
                selectedHandles.delete(h);
            } else {
                selectedHandles.add(h);
            }
        });
        updateDeleteBtn();
        updateSelectionUI();
        renderFilteredList();
    };

    expandBtn.onclick = () => document.body.classList.toggle('full-explorer');
    themeBtn.onclick = () => document.body.setAttribute('data-theme', document.body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark');
    incFontBtn.onclick = () => { baseFontSize += 2; document.documentElement.style.setProperty('--base-fs', baseFontSize + 'px'); updateEditorUI(); };
    decFontBtn.onclick = () => { if (baseFontSize > 8) { baseFontSize -= 2; document.documentElement.style.setProperty('--base-fs', baseFontSize + 'px'); updateEditorUI(); } };
    lockBtn.onclick = () => { const isLocked = editor.contentEditable === 'true'; editor.contentEditable = !isLocked; document.body.classList.toggle('is-unlocked', !isLocked); };
    
    upBtn.onclick = async () => {
        if (historyIndex > 0) {
            historyIndex--;
            const prev = navHistory[historyIndex];
            isInsideZip = prev.isZip; zipRootEntry = prev.zipRoot;
            applyNavigationState(prev.handle, false);
        } else if (isInsideZip && currentHandle.path === "") {
             isInsideZip = false; zipRootEntry = null;
             applyNavigationState(rootHandle, true);
        }
    };
    forwardBtn.onclick = () => { 
        if (historyIndex < navHistory.length - 1) { 
            historyIndex++; 
            const next = navHistory[historyIndex];
            isInsideZip = next.isZip; zipRootEntry = next.zipRoot;
            applyNavigationState(next.handle, false); 
        } 
    };
</script>
</body>

</html>
