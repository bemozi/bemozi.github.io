<script>
	call = (callback, ...arguments) => {
		try {
			callback(...arguments);
		} catch (error) {
			console.error(error.name, error.message);
		}
	};
	load = () => showDirectoryPicker({startIn: 'desktop'}).then(directoryHandle => {
		dh = directoryHandle;
		/*for await (const entry of dh.values()) console.log(entry.kind, entry.name); */
		const iterator = dh.values();
		const next = result => {
			if (result.done) return;
			const handle = result.value;
			console.log(handle.kind, handle.name);
			iterator.next().then(next);
		};
		iterator.next().then(next);
	});
	save = (content = '2025') => dh.getFileHandle('2025.txt', {create: 1}).then(fileHandle => fileHandle.createWritable()).then(writableStream => writableStream.write(content).then(() => writableStream.close()));
	read = (name = '2025') => dh.getFileHandle('2025.txt').then(fileHandle => fileHandle.getFile().then(file => file.text()).then(text => document.body.lastChild.innerHTML = text));
	removeFile = (name = '2025.txt') => dh.removeEntry(name);
	removeDirectory = (name = '2025') => dh.removeEntry(name, {recursive: 1});
	
	async function getClipboardContents() {
		try {
			const clipboardItems = await navigator.clipboard.read();
				for (const clipboardItem of clipboardItems) {
					for (const type of clipboardItem.types) {
						const blob = await clipboardItem.getType(type);
						console.log(URL.createObjectURL(blob));
					}
				}
		} catch (err) {
			console.error(err.name, err.message);
		}
	}
	
	
	async function checkClipboard() {
		try {
			// Check if clipboard API is available
			if (!navigator.clipboard || !navigator.clipboard.read) {
				console.error("Clipboard API not supported");
				return;
			}
			// Request permission (may prompt the user)
			const permissionStatus = await navigator.permissions.query({name: 'clipboard-read'});
			if (permissionStatus.state === 'denied') {
				console.error("Clipboard permission denied");
				return;
			}
			// Read clipboard items
			const clipboardItems = await navigator.clipboard.read();
			if (clipboardItems.length === 0) {
				console.log("No valid data on clipboard");
				return;
			}
			console.log("Clipboard items:", clipboardItems.length);
			for (const clipboardItem of clipboardItems) {
				if (clipboardItem.getAsFileSystemHandle) {
					const fileHandle = await clipboardItem.getAsFileSystemHandle();
					if (fileHandle) {
						if (fileHandle.kind === 'file') {
							const file = await fileHandle.getFile();
							console.log('File:', file.name, file.size);
						} else if (fileHandle.kind === 'directory') {
							console.log('Directory handle');
						}
					}
				} else {
					// Fallback for browsers that don't support getAsFileSystemHandle()
					for (const type of clipboardItem.types) {
						const blob = await clipboardItem.getType(type);
						console.log(`Data (${type}):`, blob);
					}
				}
			}
		} catch (error) {
			console.error("Error reading clipboard:", error);
		}
	}

	// Run the function
		
	
	file = async () => {
		checkClipboard();
		return;
		try {
			const clipboardItems = await navigator.clipboard.read();
			for (const clipboardItem of clipboardItems) {
				for (const type of clipboardItem.types) {
					if (type === 'text/uri-list') {
						const blob = await clipboardItem.getType(type);
						const text = await blob.text();
						// Check if it's a directory path
						if (text.startsWith('file:///')) {
							console.log('Potential directory path:', text);
						}
					}
				}
			}
		} catch (err) {
			console.error('Failed to read clipboard:', err);
		}
		/*console.log('Reading clipboard data');
		const clipboardContent = await navigator.clipboard.read();
		console.log('Data is ', clipboardContent);*/
	};
	
	onclick = async event => {
		checkClipboard();
		return;
		if (event.target === document.body) {
			try {
				const clipboardItems = await navigator.clipboard.read();
				for (const clipboardItem of clipboardItems) {
					const fileHandle = await clipboardItem.getAsFileSystemHandle();
					if (fileHandle) {
						if (fileHandle.kind === 'file') {
							const file = await fileHandle.getFile();
							console.log('File:', file.name, file.size);
						} else if (fileHandle.kind === 'directory') {
							console.log('Directory handle');
						}
					}
				}
				
				/*
				readPermissionStatus = await navigator.permissions.query({name: 'clipboard-read'});
				console.log('Read granted ? ', readPermissionStatus.state);
				readPermissionStatus.onchange = () => {
					console.log(readPermissionStatus.state);
				};
				/*
				console.log('Reading clipboard text');
				const clipboardText = await navigator.clipboard.readText();
				console.log('Text is: ', clipboardText);
				console.log('Reading clipboard data');
				const clipboardContent = await navigator.clipboard.read();
				console.log('Data is ', clipboardContent);

				// Below is some custom code which is not relevant as we never reach it
				// ...
				*/
			} catch (e) {
				console.error('Error occurred during paste !', e)
			}
			/*try {
				const clipboardItems = await navigator.clipboard.read();
				for (const clipboardItem of clipboardItems) {
					for (const type of clipboardItem.types) {
						const blob = await clipboardItem.getType(type);
						// we can now use blob here
						console.log(1);
					}
				}
			} catch (err) {
				console.error(err.name, err.message);
			}
			/*navigator.clipboard.read().then(clipboardItems => {
				for (const item of clipboardItems) {
					console.log(item.types);
					for (const type of item.types) {
						item.getType(type).then(blob => console.log(`Type: ${type}, Size: ${blob.size} bytes`));
					}
				}
			});*/
		} else call(window[event.target.innerHTML]);
	};
	
	/*
	
	https://developer.chrome.com/docs/capabilities/web-apis/file-system-access
	
	const subDir = await currentDirHandle.getDirectoryHandle(dirName, {
	  create: true,
	});
	
	// writes the data to the stream from the determined position
	writableStream.write({ type: "write", position, data });

	// updates the current file cursor offset to the position specified
	writableStream.write({ type: "seek", position });

	// resizes the file to be size bytes long
	writableStream.write({ type: "truncate", size });
	
	*/
	
	ondragover = event => event.preventDefault();
	ondrop = event => {
		event.preventDefault();
		const fileHandlesPromises = [...event.dataTransfer.items].filter(item => item.kind === 'file').map(item => item.getAsFileSystemHandle());
		Promise.all(fileHandlesPromises).then(handles => {
			dh = handles[0];
			for (const handle of handles) {
				if (handle.kind === 'directory') {
					console.log(`Directory: ${handle.name}`);
				} else {
					console.log(`File: ${handle.name}`);
				}
			}
		});
	};
	addEventListener('paste', event => {
		event.clipboardData.items[0].getAsFileSystemHandle().then(handle => {
			dh = handle;
			console.log(handle.kind, handle.name);
		});
	});
	/*
	addEventListener('drop', async (e) => {
		e.preventDefault();
		const fileHandlesPromises = [...e.dataTransfer.items].filter(item => item.kind === 'file').map(item => item.getAsFileSystemHandle());
		for await (const handle of fileHandlesPromises) {
			if (handle.kind === 'directory') {
				console.log(`Directory: ${handle.name}`);
			} else {
				console.log(`File: ${handle.name}`);
			}
		}
	});
	async function writeURLToFile(fileHandle, url) {
	  // Create a FileSystemWritableFileStream to write to.
	  const writable = await fileHandle.createWritable();
	  // Make an HTTP request for the contents.
	  const response = await fetch(url);
	  // Stream the response into the file.
	  await response.body.pipeTo(writable);
	  // pipeTo() closes the destination pipe by default, no need to close it.
	}
	*/
</script>
<div>load</div>
<div>read</div>
<div>save</div>
<div>removeFile</div>
<div>file</div>
<div></div>